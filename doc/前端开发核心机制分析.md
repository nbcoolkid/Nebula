# Nebula UI 前端项目 - 核心机制深度分析

> 本文档详细分析前端项目的四个核心主题：动态路由、权限管理、功能模块开发、API接口开发

**文档版本：** v1.0
**更新日期：** 2026-01-03
**项目路径：** `/home/sherry/workspace/Nebula/ui`

---

## 目录

- [一、动态路由逻辑分析](#一动态路由逻辑分析)
- [二、权限管理实现分析](#二权限管理实现分析)
- [三、添加新功能模块完整流程](#三添加新功能模块完整流程)
- [四、API 接口开发流程](#四-api-接口开发流程)
- [五、总结与最佳实践](#五总结与最佳实践)

---

## 一、动态路由逻辑分析

### 1.1 核心架构

项目采用 **静态路由 + 动态路由** 的混合模式，核心文件位于 `src/router/`：

```
router/
├── guards/
│   └── beforeEach.ts         # 路由守卫（核心，400+行）
├── core/
│   ├── RouteRegistry.ts      # 路由注册器
│   ├── MenuProcessor.ts      # 菜单处理器
│   ├── RouteTransformer.ts   # 路由转换器
│   ├── ComponentLoader.ts    # 组件加载器
│   └── RoutePermissionValidator.ts  # 权限验证器
├── routes/
│   ├── staticRoutes.ts       # 静态路由
│   └── asyncRoutes.ts        # 动态路由入口
└── modules/
    ├── dashboard.ts
    ├── system.ts
    └── ...其他模块
```

### 1.2 路由守卫核心流程

**文件位置：** `src/router/guards/beforeEach.ts`

#### 完整执行流程图

```
用户访问页面
    ↓
router.beforeEach 触发
    ↓
┌─────────────────────────────────────┐
│ 1. 检查登录状态                     │
│    - 已登录 → 继续                  │
│    - 未登录 → 跳转登录页            │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 2. 检查路由是否已注册               │
│    - 已注册 → 跳转到步骤 5          │
│    - 未注册 → 执行动态路由注册      │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. 动态路由注册流程                 │
│                                     │
│  3.1 获取用户信息                   │
│      → API: /api/user/info          │
│                                     │
│  3.2 获取菜单数据                   │
│      → 前端模式: 从 router/modules  │
│      → 后端模式: API 返回           │
│                                     │
│  3.3 验证菜单数据                   │
│      → MenuProcessor.validateMenuList() │
│                                     │
│  3.4 注册路由                       │
│      → RouteRegistry.register()     │
│      → 验证配置                      │
│      → 转换格式                      │
│      → 加载组件                      │
│      → router.addRoute()            │
│                                     │
│  3.5 保存到 Store                   │
│      → menuStore.setMenuList()      │
│      → menuStore.addRemoveRouteFns() │
│                                     │
│  3.6 验证权限                       │
│      → RoutePermissionValidator     │
│                                     │
│  3.7 重新导航                       │
│      → next({ path, replace: true }) │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 4. 处理根路径重定向                 │
│    → / → 首页路径                   │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 5. 检查路由是否匹配                 │
│    - 已匹配 → 设置标签页和标题      │
│    - 未匹配 → 跳转 404              │
└─────────────────────────────────────┘
    ↓
页面渲染完成
```

### 1.3 动态路由注册核心代码

```typescript
// router/guards/beforeEach.ts (248-347行)
async function handleDynamicRoutes(to, next, router) {
  routeInitInProgress = true
  pendingLoading = true
  loadingService.showLoading()

  try {
    // 步骤1: 获取用户信息
    await fetchUserInfo()

    // 步骤2: 获取菜单数据（支持前端/后端两种模式）
    const menuList = await menuProcessor.getMenuList()

    // 步骤3: 验证菜单数据
    if (!menuProcessor.validateMenuList(menuList)) {
      throw new Error('获取菜单列表失败，请重新登录')
    }

    // 步骤4: 注册动态路由（核心操作）
    routeRegistry?.register(menuList)
    // 内部流程：
    //   - 验证路由配置
    //   - 转换为 Vue Router 格式
    //   - 动态加载组件
    //   - 调用 router.addRoute()

    // 步骤5: 保存菜单数据到 Pinia Store
    const menuStore = useMenuStore()
    menuStore.setMenuList(menuList)
    menuStore.addRemoveRouteFns(routeRegistry?.getRemoveRouteFns() || [])

    // 步骤6: 保存 iframe 路由
    IframeRouteManager.getInstance().save()

    // 步骤7: 验证工作标签页
    useWorktabStore().validateWorktabs(router)

    // 步骤8: 验证目标路径权限
    const { path: validatedPath, hasPermission } =
      RoutePermissionValidator.validatePath(to.path, menuList, homePath.value)

    routeInitInProgress = false

    // 步骤9: 重新导航到目标路由
    if (!hasPermission) {
      next({ path: validatedPath, replace: true })
    } else {
      next({ path: to.path, query: to.query, hash: to.hash, replace: true })
    }
  } catch (error) {
    routeInitFailed = true
    routeInitInProgress = false
    next({ name: 'Exception500', replace: true })
  }
}
```

### 1.4 前端模式 vs 后端模式

#### 前端模式（VITE_ACCESS_MODE=frontend）

```typescript
// router/core/MenuProcessor.ts
private async processFrontendMenu(): Promise<AppRouteRecord[]> {
  const userStore = useUserStore()
  const roles = userStore.info?.roles

  let menuList = [...asyncRoutes]  // 从 router/modules 导入

  // 根据角色过滤菜单
  if (roles && roles.length > 0) {
    menuList = this.filterMenuByRoles(menuList, roles)
  }

  return this.filterEmptyMenus(menuList)
}
```

#### 后端模式（VITE_ACCESS_MODE=backend）

```typescript
private async processBackendMenu(): Promise<AppRouteRecord[]> {
  const list = await fetchGetMenuList()  // 调用后端接口
  return this.filterEmptyMenus(list)
}
```

### 1.5 组件懒加载机制

```typescript
// router/core/ComponentLoader.ts
export class ComponentLoader {
  private modules: Record<string, () => Promise<any>>

  constructor() {
    // 动态导入 views 目录下所有 .vue 组件
    this.modules = import.meta.glob('../../views/**/*.vue')
  }

  load(componentPath: string): () => Promise<any> {
    const fullPath = `../../views${componentPath}.vue`
    const fullPathWithIndex = `../../views${componentPath}/index.vue`

    // 先尝试直接路径，再尝试添加/index的路径
    const module = this.modules[fullPath] ||
                   this.modules[fullPathWithIndex]

    if (!module) {
      console.error(`未找到组件: ${componentPath}`)
      return this.createErrorComponent(componentPath)
    }

    return module
  }
}
```

**支持的路径格式：**
- `/dashboard/console` → `views/dashboard/console.vue`
- `/dashboard/console` → `views/dashboard/console/index.vue`

### 1.6 路由配置规范

#### 静态路由示例

```typescript
// router/routes/staticRoutes.ts
{
  path: '/auth/login',
  name: 'Login',
  component: () => import('@views/auth/login/index.vue'),
  meta: {
    title: 'menus.login.title',
    isHideTab: true  // 不在标签页显示
  }
}
```

#### 动态路由示例

```typescript
// router/modules/system.ts
{
  path: '/system',
  name: 'System',
  component: '/index/index',  // Layout 组件
  meta: {
    title: 'menus.system.title',
    icon: 'ri:user-3-line',
    roles: ['R_SUPER', 'R_ADMIN']  // 角色权限
  },
  children: [
    {
      path: 'user',  // 相对路径，最终会变成 /system/user
      name: 'User',
      component: '/system/user',
      meta: {
        title: 'menus.system.user',
        icon: 'ri:user-line',
        keepAlive: true,  // 页面缓存
        authList: [  // 按钮权限
          { title: '新增', authMark: 'add' },
          { title: '编辑', authMark: 'edit' },
          { title: '删除', authMark: 'delete' }
        ]
      }
    }
  ]
}
```

### 1.7 关键特性总结

✅ **双模式支持** - 前端/后端路由控制
✅ **模块化设计** - 核心功能分离到独立类
✅ **权限验证** - 角色权限 + 路径权限
✅ **组件懒加载** - 支持灵活的路径格式
✅ **嵌套路由** - 支持任意层级嵌套
✅ **防死循环机制** - 防止路由初始化失败导致无限循环
✅ **路由清理** - 登出时完整清理动态路由

---

## 二、权限管理实现分析

### 2.1 权限类型定义

#### 角色类型

| 角色编码 | 角色名称 | 说明 |
|---------|---------|------|
| `R_SUPER` | 超级管理员 | 最高权限，可访问所有功能 |
| `R_ADMIN` | 管理员 | 管理权限，可访问系统管理模块 |
| `R_USER` | 普通用户 | 基础权限 |

#### 权限标识

按钮级权限使用字符串标识：
- `add` - 新增权限
- `edit` - 编辑权限
- `delete` - 删除权限
- `export` - 导出权限
- `view` - 查看权限

### 2.2 路由级权限控制

通过路由 `meta.roles` 配置：

```typescript
// router/modules/system.ts
{
  path: '/system',
  name: 'System',
  meta: {
    title: 'menus.system.title',
    icon: 'ri:user-3-line',
    roles: ['R_SUPER', 'R_ADMIN']  // 超级管理员和管理员可访问
  },
  children: [
    {
      path: 'role',
      name: 'Role',
      meta: {
        roles: ['R_SUPER']  // 仅超级管理员可访问
      }
    }
  ]
}
```

### 2.3 按钮级权限控制

#### 步骤1：在路由 meta 中配置 authList

```typescript
{
  path: 'menu',
  name: 'Menus',
  component: '/system/menu',
  meta: {
    title: 'menus.system.menu',
    roles: ['R_SUPER'],
    authList: [                    // 按钮权限列表
      { title: '新增', authMark: 'add' },
      { title: '编辑', authMark: 'edit' },
      { title: '删除', authMark: 'delete' }
    ]
  }
}
```

#### 步骤2：使用 v-auth 指令

**文件位置：** `src/directives/core/auth.ts`

```vue
<template>
  <!-- 新增按钮 -->
  <ElButton v-auth="'add'">新增</ElButton>

  <!-- 编辑按钮 -->
  <ElButton v-auth="'edit'">编辑</ElButton>

  <!-- 删除按钮 -->
  <ElButton v-auth="'delete'">删除</ElButton>
</template>
```

### 2.4 角色权限控制

使用 `v-roles` 指令：

**文件位置：** `src/directives/core/roles.ts`

```vue
<template>
  <!-- 单个角色 -->
  <ElButton v-roles="'R_SUPER'">超级管理员功能</ElButton>

  <!-- 多个角色（满足其一即可） -->
  <ElButton v-roles="['R_SUPER', 'R_ADMIN']">管理员功能</ElButton>
</template>
```

### 2.5 编程式权限验证

使用 `useAuth` Hook：

**文件位置：** `src/hooks/core/useAuth.ts`

```typescript
import { useAuth } from '@/hooks/core/useAuth'

const { hasAuth } = useAuth()

// 检查权限
if (hasAuth('add')) {
  // 有新增权限
}

// 在模板中使用
<ElButton :disabled="!hasAuth('publish')">发布</ElButton>
```

### 2.6 权限验证逻辑

#### v-roles 指令实现

```typescript
// directives/core/roles.ts
function checkRolePermission(el: HTMLElement, binding: RolesBinding): void {
  const userStore = useUserStore()
  const userRoles = userStore.getUserInfo.roles

  if (!userRoles?.length) {
    removeElement(el)
    return
  }

  const requiredRoles = Array.isArray(binding.value) ? binding.value : [binding.value]
  const hasPermission = requiredRoles.some((role: string) => userRoles.includes(role))

  if (!hasPermission) {
    removeElement(el)
  }
}
```

#### v-auth 指令实现

```typescript
// directives/core/auth.ts
function checkAuthPermission(el: HTMLElement, binding: AuthBinding): void {
  const authList = (router.currentRoute.value.meta.authList
    as Array<{ authMark: string }>) || []

  const hasPermission = authList.some((item) => item.authMark === binding.value)

  if (!hasPermission) {
    removeElement(el)
  }
}
```

### 2.7 前端模式 vs 后端模式

| 特性 | 前端模式 | 后端模式 |
|-----|---------|---------|
| **权限来源** | 前端路由配置文件 | 后端接口返回的菜单数据 |
| **v-auth 指令** | 不可用 | 可用（基于 meta.authList） |
| **hasAuth 方法** | 可用（检查 buttons 数组） | 可用（检查 meta.authList） |
| **菜单过滤** | 前端根据用户角色过滤 | 后端返回已过滤的菜单 |
| **适用场景** | 快速原型、简单应用 | 企业级应用、复杂权限体系 |

### 2.8 权限验证最佳实践

```vue
<template>
  <!-- 推荐：使用 v-auth 指令 -->
  <el-button v-auth="'add'">新增</el-button>

  <!-- 或使用 hasAuth 方法 -->
  <el-button v-if="hasAuth('add')" @click="handleAdd">新增</el-button>

  <!-- 不推荐：硬编码权限判断 -->
  <el-button v-if="user.roles.includes('R_SUPER')">新增</el-button>
</template>

<script setup lang="ts">
const { hasAuth } = useAuth()
</script>
```

---

## 三、添加新功能模块完整流程

### 3.1 标准开发流程

#### 步骤1：创建页面组件

**文件路径：** `src/views/product/index.vue`

```vue
<template>
  <div class="product-page art-full-height">
    <!-- 搜索栏 -->
    <ProductSearch
      v-model="searchForm"
      @search="handleSearch"
      @reset="resetSearchParams"
    />

    <ElCard class="art-table-card" shadow="never">
      <!-- 表格头部 -->
      <ArtTableHeader
        v-model:columns="columnChecks"
        :loading="loading"
        @refresh="refreshData"
      >
        <template #left>
          <ElSpace wrap>
            <ElButton v-auth="'add'" @click="showDialog('add')">新增产品</ElButton>
          </ElSpace>
        </template>
      </ArtTableHeader>

      <!-- 表格 -->
      <ArtTable
        :loading="loading"
        :data="data"
        :columns="columns"
        :pagination="pagination"
        @pagination:size-change="handleSizeChange"
        @pagination:current-change="handleCurrentChange"
      />
    </ElCard>

    <!-- 产品弹窗 -->
    <ProductDialog
      v-model:visible="dialogVisible"
      :type="dialogType"
      :product-data="currentProductData"
      @submit="handleDialogSubmit"
    />
  </div>
</template>

<script setup lang="ts">
import { useTable } from '@/hooks/core/useTable'
import { fetchGetProductList } from '@/api/product-manage'
import ProductSearch from './modules/product-search.vue'
import ProductDialog from './modules/product-dialog.vue'

defineOptions({ name: 'Product' })

// 使用 useTable Hook
const {
  columns,
  columnChecks,
  data,
  loading,
  pagination,
  getData,
  searchParams,
  resetSearchParams,
  handleSizeChange,
  handleCurrentChange,
  refreshData
} = useTable({
  core: {
    apiFn: fetchGetProductList,
    apiParams: { current: 1, size: 20 },
    columnsFactory: () => [
      { type: 'selection' },
      { type: 'index', width: 60, label: '序号' },
      { prop: 'productName', label: '产品名称' },
      { prop: 'price', label: '价格' },
      {
        prop: 'operation',
        label: '操作',
        width: 120,
        fixed: 'right'
      }
    ]
  }
})
</script>
```

#### 步骤2：配置路由

**文件路径：** `src/router/modules/product.ts`

```typescript
import { AppRouteRecord } from '@/types/router'

export const productRoutes: AppRouteRecord = {
  path: '/product',
  name: 'Product',
  component: '/index/index',  // 必须使用 Layout
  meta: {
    title: 'menus.product.title',
    icon: 'ri:shopping-bag-3-line',
    roles: ['R_SUPER', 'R_ADMIN']
  },
  children: [
    {
      path: 'list',  // 不要使用 / 开头
      name: 'ProductList',
      component: '/product/list',
      meta: {
        title: 'menus.product.list',
        icon: 'ri:list-check',
        keepAlive: true,
        authList: [
          { title: '新增', authMark: 'add' },
          { title: '编辑', authMark: 'edit' },
          { title: '删除', authMark: 'delete' }
        ]
      }
    }
  ]
}
```

**注册路由模块：** `src/router/modules/index.ts`

```typescript
import { productRoutes } from './product'  // 新增

export const routeModules: AppRouteRecord[] = [
  dashboardRoutes,
  templateRoutes,
  // ...
  productRoutes,  // 新增
  // ...
]
```

#### 步骤3：定义 API 接口

**文件路径：** `src/api/product-manage.ts`

```typescript
import request from '@/utils/http'

// 获取产品列表
export function fetchGetProductList(params: Api.ProductManage.ProductSearchParams) {
  return request.get<Api.ProductManage.ProductList>({
    url: '/api/product/list',
    params
  })
}

// 获取产品详情
export function fetchGetProductDetail(id: number) {
  return request.get<Api.ProductManage.ProductDetail>({
    url: `/api/product/${id}`
  })
}

// 创建产品
export function fetchCreateProduct(data: Api.ProductManage.CreateProductParams) {
  return request.post({
    url: '/api/product',
    data,
    showSuccessMessage: true
  })
}

// 更新产品
export function fetchUpdateProduct(id: number, data: Api.ProductManage.UpdateProductParams) {
  return request.put({
    url: `/api/product/${id}`,
    data,
    showSuccessMessage: true
  })
}

// 删除产品
export function fetchDeleteProduct(id: number) {
  return request.delete({
    url: `/api/product/${id}`,
    showSuccessMessage: true
  })
}
```

#### 步骤4：添加类型定义

**文件路径：** `src/types/api/api.d.ts`

```typescript
declare namespace Api {
  /** 产品管理类型 */
  namespace ProductManage {
    /** 产品列表 */
    type ProductList = Api.Common.PaginatedResponse<ProductListItem>

    /** 产品列表项 */
    interface ProductListItem {
      id: number
      productName: string
      productCode: string
      price: number
      category: string
      status: string
      createTime: string
    }

    /** 产品详情 */
    interface ProductDetail extends ProductListItem {
      description: string
      images: string[]
    }

    /** 产品搜索参数 */
    interface ProductSearchParams extends Api.Common.CommonSearchParams {
      productName?: string
      productCode?: string
      category?: string
      status?: string
    }

    /** 创建产品参数 */
    interface CreateProductParams {
      productName: string
      productCode: string
      price: number
      category: string
      description: string
    }
  }
}
```

#### 步骤5：添加国际化文本

**中文：** `src/locales/langs/zh.json`

```json
{
  "menus": {
    "product": {
      "title": "产品管理",
      "list": "产品列表"
    }
  },
  "product": {
    "name": "产品名称",
    "code": "产品编码",
    "price": "价格",
    "addProduct": "新增产品",
    "editProduct": "编辑产品"
  }
}
```

**英文：** `src/locales/langs/en.json`

```json
{
  "menus": {
    "product": {
      "title": "Product",
      "list": "Product List"
    }
  }
}
```

### 3.2 核心组件和 Hooks 使用

#### useTable Hook

**文件位置：** `src/hooks/core/useTable.ts`

**功能：**
- ✅ 自动处理 API 请求
- ✅ 分页控制
- ✅ 搜索功能（防抖）
- ✅ 数据缓存
- ✅ 刷新策略
- ✅ 列配置管理

**使用示例：**

```typescript
const {
  columns,           // 列配置
  columnChecks,      // 列显示状态
  data,             // 表格数据
  loading,          // 加载状态
  pagination,       // 分页信息
  getData,          // 获取数据
  searchParams,     // 搜索参数
  resetSearchParams,// 重置搜索
  handleSizeChange, // 每页条数变化
  handleCurrentChange, // 当前页变化
  refreshData       // 刷新数据
} = useTable({
  core: {
    apiFn: fetchGetProductList,
    apiParams: { current: 1, size: 20 },
    columnsFactory: () => [
      { type: 'selection' },
      { type: 'index', width: 60, label: '序号' },
      { prop: 'name', label: '名称' }
    ]
  }
})
```

#### ArtTable 组件

**文件位置：** `src/components/core/tables/art-table/`

**特性：**
- 支持 Element Plus Table 所有属性
- 内置分页组件
- 支持列配置管理
- 支持斑马纹、边框、尺寸配置

#### ArtSearchBar 组件

**文件位置：** `src/components/core/forms/art-search-bar/`

**特性：**
- 支持多种表单类型
- 自动布局响应式
- 展开/收起功能
- 表单验证

### 3.3 目录组织最佳实践

```
views/your-module/
├── index.vue              # 主页面
└── modules/              # 子模块
    ├── xxx-search.vue    # 搜索组件
    ├── xxx-dialog.vue    # 弹窗组件
    └── xxx-form.vue      # 表单组件
```

**组件拆分原则：**
- 搜索区域 → 独立为 `xxx-search.vue`
- 弹窗/表单 → 独立为 `xxx-dialog.vue`
- 可复用部分 → 提取到 `components/` 下

---

## 四、API 接口开发流程

### 4.1 HTTP 封装机制

**文件位置：** `src/utils/http/index.ts`

#### 核心配置

```typescript
// 请求配置常量
const REQUEST_TIMEOUT = 15000          // 请求超时时间
const UNAUTHORIZED_DEBOUNCE_TIME = 3000 // 401防抖时间

const axiosInstance = axios.create({
  timeout: REQUEST_TIMEOUT,
  baseURL: VITE_API_URL,              // 从环境变量读取
  withCredentials: VITE_WITH_CREDENTIALS === 'true'
})
```

#### 环境变量配置

```bash
# .env.development
VITE_API_URL = /
VITE_API_PROXY_URL = https://m1.apifoxmock.com/m1/xxx

# .env.production
VITE_API_URL = https://api.example.com
```

### 4.2 请求拦截器

```typescript
axiosInstance.interceptors.request.use(
  (request: InternalAxiosRequestConfig) => {
    const { accessToken } = useUserStore()

    // 自动添加 Token
    if (accessToken) {
      request.headers.set('Authorization', accessToken)
    }

    // 自动设置 Content-Type
    if (request.data && !(request.data instanceof FormData)) {
      request.headers.set('Content-Type', 'application/json')
      request.data = JSON.stringify(request.data)
    }

    return request
  }
)
```

### 4.3 响应拦截器

```typescript
axiosInstance.interceptors.response.use(
  (response: AxiosResponse<BaseResponse>) => {
    const { code, msg } = response.data

    // 成功响应
    if (code === ApiStatus.success) {
      // 显示成功消息（可选）
      if (config.showSuccessMessage && res.data.msg) {
        showSuccess(res.data.msg)
      }
      // 自动返回 data 字段
      return response.data.data as T
    }

    // 401 未授权
    if (code === ApiStatus.unauthorized) {
      handleUnauthorizedError(msg)
      throw createHttpError(msg, code)
    }

    // 其他错误
    throw createHttpError(msg || $t('httpMsg.requestFailed'), code)
  }
)
```

### 4.4 401 自动登出（带防抖）

```typescript
// 401防抖状态
let isUnauthorizedErrorShown = false
let unauthorizedTimer: NodeJS.Timeout | null = null

// 处理401错误（带防抖）
function handleUnauthorizedError(message?: string): never {
  const error = createHttpError(message || $t('httpMsg.unauthorized'), ApiStatus.unauthorized)

  if (!isUnauthorizedErrorShown) {
    isUnauthorizedErrorShown = true
    logOut()  // 自动登出

    unauthorizedTimer = setTimeout(resetUnauthorizedError, UNAUTHORIZED_DEBOUNCE_TIME)
    showError(error, true)
    throw error
  }

  throw error
}
```

### 4.5 API 接口定义规范

#### 完整示例

```typescript
// src/api/order.ts
import request from '@/utils/http'

/**
 * 获取订单列表
 */
export function fetchGetOrderList(params: OrderSearchParams) {
  return request.get<OrderList>({
    url: '/api/order/list',
    params,
    showErrorMessage: true
  })
}

/**
 * 获取订单详情
 */
export function fetchGetOrderDetail(id: number) {
  return request.get<Order>({
    url: `/api/order/${id}`,
    showErrorMessage: true
  })
}

/**
 * 创建订单
 */
export function fetchCreateOrder(data: CreateOrderParams) {
  return request.post<Order>({
    url: '/api/order/create',
    data,
    showSuccessMessage: true,
    showErrorMessage: true
  })
}

/**
 * 删除订单
 */
export function fetchDeleteOrder(id: number) {
  return request.delete<void>({
    url: `/api/order/${id}`,
    showSuccessMessage: true,
    showErrorMessage: true
  })
}
```

### 4.6 类型定义规范

**文件位置：** `src/types/api/api.d.ts`

```typescript
declare namespace Api {
  /** 通用类型 */
  namespace Common {
    /** 分页参数 */
    interface PaginationParams {
      current: number
      size: number
      total: number
    }

    /** 分页响应基础结构 */
    interface PaginatedResponse<T = any> {
      records: T[]
      current: number
      size: number
      total: number
    }

    /** 通用搜索参数 */
    type CommonSearchParams = Pick<PaginationParams, 'current' | 'size'>
  }

  /** 认证类型 */
  namespace Auth {
    interface LoginParams {
      userName: string
      password: string
    }

    interface LoginResponse {
      token: string
      refreshToken: string
    }

    interface UserInfo {
      buttons: string[]    // 前端模式：按钮权限列表
      roles: string[]      // 用户角色列表
      userId: number
      userName: string
      email: string
      avatar?: string
    }
  }

  /** 系统管理类型 */
  namespace SystemManage {
    type UserList = Api.Common.PaginatedResponse<UserListItem>

    interface UserListItem {
      id: number
      avatar: string
      status: string
      userName: string
      userGender: string
      nickName: string
      userPhone: string
      userEmail: string
      userRoles: string[]
    }

    type UserSearchParams = Partial<
      Pick<UserListItem, 'id' | 'userName' | 'userGender' | 'userPhone' | 'userEmail' | 'status'> &
        Api.Common.CommonSearchParams
    >
  }
}
```

### 4.7 在组件中使用 API

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { fetchGetOrderList, fetchCreateOrder } from '@/api/order'
import { HttpError } from '@/utils/http/error'
import { ElMessage } from 'element-plus'

// 数据列表
const orderList = ref<Order[]>([])
const loading = ref(false)
const pagination = reactive({
  current: 1,
  size: 10,
  total: 0
})

// 获取订单列表
const getOrderList = async () => {
  try {
    loading.value = true
    const res = await fetchGetOrderList({
      current: pagination.current,
      size: pagination.size
    })
    orderList.value = res.records
    pagination.total = res.total
  } catch (error) {
    if (error instanceof HttpError) {
      console.error('获取订单列表失败:', error.message)
    }
  } finally {
    loading.value = false
  }
}

// 创建订单
const handleCreate = async (formData: CreateOrderParams) => {
  try {
    await fetchCreateOrder(formData)
    ElMessage.success('创建成功')
    await getOrderList()  // 刷新列表
  } catch (error) {
    // 错误已被拦截器处理，这里可以做额外处理
    console.error('创建失败')
  }
}

onMounted(() => {
  getOrderList()
})
</script>
```

### 4.8 错误处理

```typescript
import { HttpError } from '@/utils/http/error'

try {
  const data = await fetchLogin({ userName: 'admin', password: '123456' })
  // 成功处理
} catch (error) {
  if (error instanceof HttpError) {
    // 类型守卫，可以访问 error.code
    switch (error.code) {
      case 401:
        console.log('未授权')
        break
      case 403:
        console.log('禁止访问')
        break
      case 500:
        console.log('服务器错误')
        break
    }
  }
}
```

### 4.9 请求参数类型

```typescript
// 路径参数
fetchGetProductDetail(id: number) {
  return request.get<Product>({
    url: `/api/product/${id}`  // 路径参数直接拼接
  })
}

// 查询参数（Query String）
fetchGetProductList(params: { current: number; size: number }) {
  return request.get<ProductList>({
    url: '/api/product/list',
    params  // GET 请求使用 params
  })
}

// 请求体（Body）
fetchCreateProduct(data: CreateProductParams) {
  return request.post<Product>({
    url: '/api/product/create',
    data  // POST/PUT 请求使用 data
  })
}

// 文件上传
fetchUploadFile(file: File) {
  const formData = new FormData()
  formData.append('file', file)

  return request.post<{ url: string }>({
    url: '/api/upload',
    data: formData,
    headers: {
      'Content-Type': 'multipart/form-data'
    }
  })
}
```

---

## 五、总结与最佳实践

### 5.1 核心优势

#### 动态路由系统
- ✅ 双模式支持（前端/后端）
- ✅ 模块化设计
- ✅ 完善的权限验证
- ✅ 组件懒加载
- ✅ 防死循环机制

#### 权限管理体系
- ✅ 三级权限控制（路由级、按钮级、数据级）
- ✅ 双权限指令（v-auth、v-roles）
- ✅ 统一权限 Hook（useAuth）
- ✅ RBAC 模型

#### 功能模块开发
- ✅ 清晰的开发流程
- ✅ 丰富的核心组件
- ✅ 强大的 useTable Hook
- ✅ 完整的 TypeScript 类型

#### API 接口开发
- ✅ 统一的 HTTP 封装
- ✅ 自动 Token 管理
- ✅ 完善的错误处理
- ✅ 类型安全

### 5.2 关键文件速查

| 功能 | 文件路径 |
|------|----------|
| **路由守卫** | `src/router/guards/beforeEach.ts` |
| **路由注册器** | `src/router/core/RouteRegistry.ts` |
| **菜单处理器** | `src/router/core/MenuProcessor.ts` |
| **权限指令** | `src/directives/core/auth.ts`, `src/directives/core/roles.ts` |
| **权限 Hook** | `src/hooks/core/useAuth.ts` |
| **表格 Hook** | `src/hooks/core/useTable.ts` |
| **HTTP 封装** | `src/utils/http/index.ts` |
| **类型定义** | `src/types/api/api.d.ts` |

### 5.3 开发建议

#### 命名规范

```typescript
// API 函数命名
fetchGetUserList()    // 获取列表
fetchGetUserDetail()  // 获取详情
fetchCreateUser()     // 创建
fetchUpdateUser()     // 更新
fetchDeleteUser()     // 删除

// 类型命名
interface UserListItem {}      // 列表项
interface UserDetail {}        // 详情
interface CreateUserParams {}  // 创建参数
interface UpdateUserParams {}  // 更新参数
type UserList = PaginatedResponse<UserListItem>  // 列表响应
```

#### 路由配置规范

```typescript
// ✅ 正确
{
  path: 'list',  // 子路由不要使用 / 开头
  component: '/product/list'
}

// ❌ 错误
{
  path: '/list',  // 不要使用 / 开头
  component: '/product/list'
}
```

#### 权限控制规范

```vue
<template>
  <!-- ✅ 推荐：使用 v-auth 指令 -->
  <el-button v-auth="'add'">新增</el-button>

  <!-- ✅ 推荐：使用 hasAuth 方法 -->
  <el-button v-if="hasAuth('add')" @click="handleAdd">新增</el-button>

  <!-- ❌ 不推荐：硬编码权限判断 -->
  <el-button v-if="user.roles.includes('R_SUPER')">新增</el-button>
</template>
```

#### API 定义规范

```typescript
// ✅ 推荐：明确的类型定义
export function fetchGetUserList(params: Api.SystemManage.UserSearchParams) {
  return request.get<Api.SystemManage.UserList>({
    url: '/api/user/list',
    params
  })
}

// ❌ 不推荐：使用 any
export function fetchGetUserList(params: any) {
  return request.get({
    url: '/api/user/list',
    params
  })
}
```

### 5.4 常见问题

#### Q1: 如何添加不需要权限的页面？

```typescript
// 在 staticRoutes.ts 中添加
{
  path: '/about',
  name: 'About',
  component: () => import('@views/about/index.vue'),
  meta: {
    title: '关于我们',
    isHideTab: true  // 不在标签页显示
  }
}
```

#### Q2: 如何实现页面缓存？

```typescript
// 在路由 meta 中配置 keepAlive
{
  path: 'list',
  name: 'ProductList',
  component: '/product/list',
  meta: {
    keepAlive: true  // 启用页面缓存
  }
}
```

#### Q3: 如何自定义错误消息？

```typescript
export function fetchCreateProduct(data: CreateProductParams) {
  return request.post({
    url: '/api/product',
    data,
    showSuccessMessage: false,  // 关闭自动成功消息
    showErrorMessage: false     // 关闭自动错误消息
  })
}

// 然后在组件中手动处理
try {
  await fetchCreateProduct(data)
  ElMessage.success('创建成功')
} catch (error) {
  ElMessage.error('创建失败：' + error.message)
}
```

#### Q4: 如何取消请求？

```typescript
// 使用 AbortController
const controller = new AbortController()

export function fetchGetUserList(params: UserSearchParams) {
  return request.get<UserList>({
    url: '/api/user/list',
    params,
    signal: controller.signal  // 传入 signal
  })
}

// 取消请求
controller.abort()
```

### 5.5 参考资源

- [Vue 3 官方文档](https://cn.vuejs.org/)
- [Element Plus 文档](https://element-plus.org/)
- [Vite 文档](https://cn.vitejs.dev/)
- [Pinia 文档](https://pinia.vuejs.org/)
- [Vue Router 文档](https://router.vuejs.org/)

---

## 附录

### A. 完整的路由配置示例

```typescript
import { AppRouteRecord } from '@/types/router'

export const exampleRoutes: AppRouteRecord = {
  path: '/example',
  name: 'Example',
  component: '/index/index',
  redirect: '/example/dashboard',
  meta: {
    title: 'menus.example.title',
    icon: 'ri:example-line',
    roles: ['R_SUPER', 'R_ADMIN']
  },
  children: [
    {
      path: 'dashboard',
      name: 'ExampleDashboard',
      component: '/example/dashboard',
      meta: {
        title: 'menus.example.dashboard',
        icon: 'ri:dashboard-line',
        keepAlive: true,
        fixedTab: true  // 固定标签页
      }
    },
    {
      path: 'list',
      name: 'ExampleList',
      component: '/example/list',
      meta: {
        title: 'menus.example.list',
        icon: 'ri:list-line',
        keepAlive: true,
        authList: [
          { title: '新增', authMark: 'add' },
          { title: '编辑', authMark: 'edit' },
          { title: '删除', authMark: 'delete' },
          { title: '导出', authMark: 'export' }
        ]
      }
    }
  ]
}
```

### B. 完整的 API 定义示例

```typescript
// src/api/example.ts
import request from '@/utils/http'

/**
 * 获取示例列表
 */
export function fetchGetExampleList(params: Api.Example.SearchParams) {
  return request.get<Api.Example.List>({
    url: '/api/example/list',
    params
  })
}

/**
 * 获取示例详情
 */
export function fetchGetExampleDetail(id: number) {
  return request.get<Api.Example.Detail>({
    url: `/api/example/${id}`,
    showErrorMessage: true
  })
}

/**
 * 创建示例
 */
export function fetchCreateExample(data: Api.Example.CreateParams) {
  return request.post<Api.Example.Detail>({
    url: '/api/example',
    data,
    showSuccessMessage: true,
    showErrorMessage: true
  })
}

/**
 * 更新示例
 */
export function fetchUpdateExample(id: number, data: Api.Example.UpdateParams) {
  return request.put<Api.Example.Detail>({
    url: `/api/example/${id}`,
    data,
    showSuccessMessage: true,
    showErrorMessage: true
  })
}

/**
 * 删除示例
 */
export function fetchDeleteExample(id: number) {
  return request.delete<void>({
    url: `/api/example/${id}`,
    showSuccessMessage: true,
    showErrorMessage: true
  })
}

/**
 * 批量删除示例
 */
export function fetchBatchDeleteExample(ids: number[]) {
  return request.post<void>({
    url: '/api/example/batch-delete',
    data: { ids },
    showSuccessMessage: true,
    showErrorMessage: true
  })
}
```

---

**文档结束**

如有疑问或建议，请联系项目维护人员。
